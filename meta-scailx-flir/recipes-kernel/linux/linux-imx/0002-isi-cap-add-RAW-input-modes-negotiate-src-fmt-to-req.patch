From 6f1d434f42310e86c85f23d1a46438ddf2148924 Mon Sep 17 00:00:00 2001
From: Kobus Goosen <kgoosen@videologyinc.com>
Date: Wed, 29 Oct 2025 15:28:19 +0100
Subject: [PATCH] isi-cap: add RAW input modes, negotiate src-fmt to req-fmt
 and add debugs

---
 drivers/staging/media/imx/imx8-isi-cap.c | 96 +++++++++++++++++++++---
 1 file changed, 87 insertions(+), 9 deletions(-)

diff --git a/drivers/staging/media/imx/imx8-isi-cap.c b/drivers/staging/media/imx/imx8-isi-cap.c
index c3d6bbeed6a2..c5fd906f8144 100644
--- a/drivers/staging/media/imx/imx8-isi-cap.c
+++ b/drivers/staging/media/imx/imx8-isi-cap.c
@@ -54,6 +54,48 @@ struct mxc_isi_fmt mxc_isi_src_formats[] = {
 		.memplanes	= 1,
 		.colplanes	= 1,
 		.align		= 2,
+	}, {
+		.name		= "RAW8",
+		.fourcc		= V4L2_PIX_FMT_GREY,
+		.depth		= { 8 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 1,
+	}, {
+		.name		= "RAW10",
+		.fourcc		= V4L2_PIX_FMT_Y10,
+		.depth		= { 16 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+	}, {
+		.name		= "RAW12",
+		.fourcc		= V4L2_PIX_FMT_Y12,
+		.depth		= { 16 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+	}, {
+		.name		= "RAW14",
+		.fourcc		= V4L2_PIX_FMT_Y14,
+		.depth		= { 16 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+	}, {
+		.name		= "RAW16",
+		.fourcc		= V4L2_PIX_FMT_Y16,
+		.depth		= { 16 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 2,
+	}, {
+		.name		= "JPEG",
+		.fourcc		= V4L2_PIX_FMT_JPEG,
+		.depth		= { 8 },
+		.memplanes	= 1,
+		.colplanes	= 1,
+		.align		= 3,
 	}
 };
 
@@ -91,17 +133,27 @@ struct mxc_isi_fmt *mxc_isi_find_format(const u32 *pixelformat,
 struct mxc_isi_fmt *mxc_isi_get_src_fmt(struct v4l2_subdev_format *sd_fmt)
 {
 	u32 index;
-
 	/* two fmt RGB32 and YUV444 from pixellink */
-	if (sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_1X16 ||
+	if (sd_fmt->format.code == MEDIA_BUS_FMT_Y14_1X14) {
+		index = 5;
+	} else if (sd_fmt->format.code == MEDIA_BUS_FMT_Y12_1X12) {
+		index = 4;
+	} else if (sd_fmt->format.code == MEDIA_BUS_FMT_Y10_1X10 ||
+		sd_fmt->format.code == MEDIA_BUS_FMT_SBGGR10_1X10) {
+		index = 3;
+	} else if (sd_fmt->format.code == MEDIA_BUS_FMT_Y8_1X8 ||
+		sd_fmt->format.code == MEDIA_BUS_FMT_SBGGR8_1X8) {
+		index = 2;
+	} else if (sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_1X16 ||
 	    sd_fmt->format.code == MEDIA_BUS_FMT_YVYU8_2X8 ||
 	    sd_fmt->format.code == MEDIA_BUS_FMT_AYUV8_1X32 ||
 	    sd_fmt->format.code == MEDIA_BUS_FMT_UYVY8_2X8 ||
 	    sd_fmt->format.code == MEDIA_BUS_FMT_UYVY8_1X16||
-	    sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_2X8)
+	    sd_fmt->format.code == MEDIA_BUS_FMT_YUYV8_2X8) {
 		index = 1;
-	else
+	} else {
 		index = 0;
+	}
 	return &mxc_isi_src_formats[index];
 }
 
@@ -667,6 +719,10 @@ static int isi_cap_fmt_init(struct mxc_isi_cap_dev *isi_cap)
 	struct v4l2_subdev *src_sd;
 	int i, ret;
 
+	if (dst_f->fmt != NULL && src_f->fmt != NULL) {
+		return 0;
+	}
+
 	src_sd = mxc_get_remote_subdev(&isi_cap->sd, __func__);
 	if (!src_sd) {
 		v4l2_err(&isi_cap->sd, "get remote subdev fail!\n");
@@ -683,6 +739,7 @@ static int isi_cap_fmt_init(struct mxc_isi_cap_dev *isi_cap)
 
 	if (dst_f->width == 0 || dst_f->height == 0)
 		set_frame_bounds(dst_f, src_fmt.format.width, src_fmt.format.height);
+	dst_f->fmt = mxc_isi_find_format(NULL, &src_fmt.format.code, 0);
 
 	if (!dst_f->fmt)
 		dst_f->fmt = &mxc_isi_out_formats[0];
@@ -856,6 +913,20 @@ static int mxc_isi_cap_g_fmt_mplane(struct file *file, void *fh,
 	return 0;
 }
 
+/*  Print Four-character-code (FOURCC) */
+static char *fourcc_to_str(u32 fmt)
+{
+	static char code[5];
+
+	code[0] = (unsigned char)(fmt & 0xff);
+	code[1] = (unsigned char)((fmt >> 8) & 0xff);
+	code[2] = (unsigned char)((fmt >> 16) & 0xff);
+	code[3] = (unsigned char)((fmt >> 24) & 0xff);
+	code[4] = '\0';
+
+	return code;
+}
+
 static struct mxc_isi_fmt *
 mxc_isi_cap_fmt_try(struct mxc_isi_cap_dev *isi_cap,
 		    struct v4l2_pix_format_mplane *pix)
@@ -867,13 +938,15 @@ mxc_isi_cap_fmt_try(struct mxc_isi_cap_dev *isi_cap,
 
 	for (i = 0; i < mxc_isi_out_formats_size; i++) {
 		fmt = &mxc_isi_out_formats[i];
-		if (fmt->fourcc == pix->pixelformat)
+		if (fmt->fourcc == pix->pixelformat) {
+			dev_dbg(&isi_cap->pdev->dev, "%s: found format %s\n", __func__, fourcc_to_str(fmt->fourcc));
 			break;
+		}
 	}
 
 	if (i >= mxc_isi_out_formats_size) {
 		fmt = &mxc_isi_out_formats[0];
-		v4l2_warn(&isi_cap->sd, "Not match format, set default\n");
+		v4l2_warn(&isi_cap->sd, "mxc_isi_cap_fmt_try: Not match format 0x%x, set default\n", pix->pixelformat);
 	}
 
 	/*
@@ -906,15 +979,19 @@ mxc_isi_cap_fmt_try(struct mxc_isi_cap_dev *isi_cap,
 		else
 			bpl = pix->plane_fmt[0].bytesperline;
 
+		dev_dbg(&isi_cap->pdev->dev, "%s: bpl: %d, plane_bpl: %d \n", __func__, bpl, plane->bytesperline);
+		dev_dbg(&isi_cap->pdev->dev, "%s: pix: width: %d, height: %d, depth: %d\n", __func__, pix->width, pix->height, fmt->depth[i]);
 		plane->bytesperline = bpl;
 		plane->sizeimage = plane->bytesperline * pix->height;
+		if (pix->pixelformat == V4L2_PIX_FMT_Y16)
+			plane->bytesperline = bpl / 2;
 
-		if ((i == 1) && (pix->pixelformat == V4L2_PIX_FMT_NV12 ||
-				 pix->pixelformat == V4L2_PIX_FMT_NV12M))
+		if ((i == 1) && (pix->pixelformat == V4L2_PIX_FMT_NV12 || pix->pixelformat == V4L2_PIX_FMT_NV12M))
 			plane->sizeimage /= 2;
 	}
 
 	if (fmt->colplanes != fmt->memplanes) {
+		dev_dbg(&isi_cap->pdev->dev, "%s: colp NQ mempl: %d, %d, set 0\n", __func__, fmt->colplanes, fmt->memplanes);
 		for (i = 1; i < fmt->colplanes; ++i) {
 			struct v4l2_plane_pix_format *plane = &pix->plane_fmt[i];
 
@@ -960,7 +1037,7 @@ static int mxc_isi_source_fmt_init(struct mxc_isi_cap_dev *isi_cap)
 
 	src_fmt.pad = source_pad->index;
 	src_fmt.which = V4L2_SUBDEV_FORMAT_ACTIVE;
-	src_fmt.format.code = MEDIA_BUS_FMT_UYVY8_1X16;
+	src_fmt.format.code = dst_f->fmt->mbus_code;
 	src_fmt.format.width = dst_f->width;
 	src_fmt.format.height = dst_f->height;
 	ret = v4l2_subdev_call(src_sd, pad, set_fmt, NULL, &src_fmt);
@@ -979,6 +1056,7 @@ static int mxc_isi_source_fmt_init(struct mxc_isi_cap_dev *isi_cap)
 	}
 
 	/* Pixel link master will transfer format to RGB32 or YUV32 */
+	dev_dbg(&isi_cap->pdev->dev, "%s: mxc_isi_get_src_fmt: src fmt code=0x%X\n", __func__, src_fmt.format.code);
 	src_f->fmt = mxc_isi_get_src_fmt(&src_fmt);
 
 	set_frame_bounds(src_f, src_fmt.format.width, src_fmt.format.height);
